# ⚠️Este projeto é um fork do repositório [delphi-exemplo-sistema](https://github.com/eversonturossi/delphi-exemplo-sistema)
>
## Código Legado
>
* Seu código é fácil de alterar?
* Você recebe feedback quase instantâneo quando o altera? 
* Você o entende?

Se a resposta para essas perguntas for "não", você tem um código legado e ele está consumindo tempo e dinheiro de seus esforços de desenvolvimento.

> Existem diversos padrões que podem ser aplicados na refatoração do seu código, e é esse os padrões que iremos aplicar nesse projeto, e creio que irá ajudar muitos
> a aproveitar mais seus sistemas legados, mais desempenho, mais funcionalidades, mais confiabilidade e mais capacidade de gerenciamento. 

> ## A refatoração segue alguns parametros, que seguindo conseguiremos ter um código coeso e de boa qualidade.

> ### Princípios da refatoração

* Definir a refatoração
* Dois chapéus
* Por que devemos refatorar?
* Quando devemos refatorar?
* Refatoração, arquitetura e Yagni
* Refatoração e o processo mais amplo de desenvolvimento de software
* Refatoração e desempenho
* "Maus cheiros" no código
* Escreva teste

> ### Conjunto de refatorações
* Extract Funtion
* Inline Function
* Extract Variable
* Inline Variable
* Change Function Declaration
* Encapsulate Variable
* Rename Variable
* Introduce Parameter Object
* Combine Functions into Class
* Compine Functions into Transform
* Split Phase

> ### Encapsulamento
* Encapsulate Record
* Encapsulate Collection
* Replace Primitive with Object
* Replace Temp with Query
* Extract Class
* Inline Class
* Hide Delegate
* Remove Middle Man
* Substitute Algorithm

> ### Movendo Recursos
* Move Function
* Move Field
* Move Statements into Function
* Move Statements to Callers
* Replace Inline Code with Function Call
* Slide Statements
* Split Loop
* Replace Loop with Pipeline
* Remove Dead Code

> ### Organizando dados
* Split Variable
* Rename Field
* Replace Derived Variable with Query
* Change Reference to Value
* Change Value to Reference

> ### Simplificando lógicas condicionais
* Decompose Conditional
* Consolidate Conditional Expression
* Replace Nested Conditional with Guard Clauses
* Replace Condicional with Plymorphism
* Introduce Special Case
* Introduce Assertion

> ### Lidando com herança
* Pull Up Method
* Pull Up Field
* Pull Up Constructor Body
* Push Down Method
* Push Down Method
* Push Down Field
* Replace Type Code with Subclasses
* Remove Subclass
* Extract Superclass
* Collapse Hierarchy
* replace SubClass with Delegate
* replace Superclass with Delegate

## Será utilizado alguns principios e padrões para o projeto

> ### Princípios

* Single Responsibility Principle (SRP)
* Open Closed Principle (OCP)
* Liskov Substitution Principle (LSP)
* Interface Segregation Principle (ISP)
* Dependency Inversion Principle (DIP)
* Separation of Concerns (SOC)
* Don't Repeat Yourself (DRY)
* You Aren't Gonna Need It (YAGNI)
* Keep It Simple, Silly (KISS)
* Composition Over Inheritance
* Small Commits

> ### Design Patterns

* Factory
* Adapter
* Composite
* Decorator
* Proxy
* Dependency Injection
* Abstract Server
* Composition Root
* Builder
* Singleton

> ### Metodologias e Designs

* TDD
* Clean Architecture
* DDD
* Conventional Commits
* GitFlow
* Modular Design
* Dependency Diagrams
* Use Cases
* Continuous Integration
* Continuous Delivery
* Continuous Deployment
